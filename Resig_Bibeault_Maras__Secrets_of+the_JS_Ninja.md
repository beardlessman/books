# Джон Резиг, Беэр Бибо, Иосип Марас. «Секреты JavaScript ниндзя» 
## 2-е издание

## Оглавление

* [5. Замыкания и области видимости](#Замыкания-и-области-видимости)
* [6. Генераторы и обещания](#Генераторы-и-обещания)
* [7. ООП с помощью прототипов](#ООП-с-помощью-прототипов)



## Замыкания и области видимости
[↑ up](#оглавление) 

Замыкание -- доступность для функции всех переменных (в т.ч. других функций), которые оказываются в области видимости в момент ее определения.
Простейшее замыкание:
```
var outerValue = 'kek';
car later;

function outerFunc () {
    var innerValue = 'lol';
    function innerFunc() {
        assert(outerValue === 'kek', 'I see the kek'); // true
        assert(innerValue === 'lol', 'I see the lol'); // true
    }
    later = innerFunc;
}

outerFunc();
later();
```

Замыкание функции `innerFunc` сохраняет переменные в областе ее видимости до тех пор, пока существует сама функция. Т.е. замыкания требуют дополнительных затрат оперативной памяти, пока интерпретатор JS не соберет мусор или пока не завершится выгрузка страницы.

### Применение замыканий

#### Имитация закрытых переменных
```
function Ninja() {
    var feints = 0;
    this.getFeints = function() {
        return feints;
    };
    this.feint = function() {
        feints++;
    };
}
```
Переменная `feints` доступна внутренним методам через их замыкания, но недоступна снаружи конструктора.

#### Применение замыканий при обратных вызовах

```
function animate(elementId) {
    var elem = document.getElementById(elementId);
    var tick = 0;

    var timer = setInterval(function(){
        if (tick < 100) {
            elem.style.left = tick + 'px';
            tick++;
        } else {
            clearInterval(timer);
            assert(tick === 100, 'tick accessed via a closure');
            assert(elem, 'elem accessed via a closure');
            assert(timer, 'timer accessed via a closure');
        }
    }, 10);
    animate('box');
}
```
Подобная реализация (без хранения `elem`, 'tick` и `timer` в глобальной области видимости) позволяет запускать несколько независимых анимаций -- каждая анимация получит свой набор переменных. Без замыканий реализовать такое крайне трудно.
Также, в этом примере видно, что нам доступно обновление переменных, а не только их значения в момент создания замыкания.

### Отслеживане выполнения кода с помощью контекстов выполнения
 
JS код может быть глобальным (один для программы/веб-страницы) и кодом функции. Аналогично, различают глобальный контекст выполнения и контекст выполнения функции. При вызове функции прерывается ее текущий контекст выполнения и возникает новый контекст выполнения функции. Когда функция завершает работу, ее контекст выполнения удаляется и восстанавливается контекст выполнения вызвавщего ее кода. Этот механизм реализован с помощью стека контекстов выполнения (стек вызовов). Стеком вызовов можно ползоваться в отладчике JS.

### Отслеживание идентификаторов с помощью лексических сред

Кроме слежения за местом выполнения кода, контекст играет выжную роль в анализе идентификаторов -- сопоставление переменных конкретным идентификаторам через лексическую среду (реализация области видимости).
До ES6 лексическая среда была связана только с функцией. Сейчас реализованы области видимости блоков.
Структура кода (функция, цикл и т.д.) связывается с лексической средой каждый раз, когда интерпретируется код (при каждом вызове функции воздается ее новая лексическая среда).
Внутренная структура кода имеет доступ к переменным, определенным во внешней структуре. Следовательно, в каждой лексической среде отслеживается ее внешня (родительская) лексическая среда.
Лексическая среда функции содержит таблицу всех идентификаторов, определенных в данном контексте + ссылку на лексическую среду, в которой эта функция была создана (лежит во внутреннем свойстве `[[Environment]]`).

### Переменные

Типы объявления переменных `var`, `let` и `const` различаются в двух вещах: изменяемость и связь с лексической средой.
Значения `const` неизменяемы -- устанавливаются один раз.
Значения `var` и `let` можно изменять сколько угодно раз.

`const` используются в двух случаях:
- для указания переменных, которые не должны больше переназначаться
- для обращения к фиксированному значению по имени
В обоих случаях код защищен, так как переменную `const` нельзя переназначить. Но можно видоизменить текущее значение (добавить/изменить свойства объекта, добавить/изменить элемент массива).

#### Переменные и лексическая среда

`var` определяется в ближайшей лексической среде контекста функции или глобального контекста (блоки кода игнорируются).
`let` и `const` могут быть определены на уровне блока.

### Механизм замыканий

По сути, замыкания -- это лишь побочное эффект от правил соблюдения области видимости. Если проследить в примерах, как создаются лексические среды (с локальными переменными и ссылками на внешние среды), то станет прозрачным. откуда доступна та или иная переменная.
Еще раз -- замыкания предоставляют функции доступ ко всем переменным (динамично), находившимся в области видимости в момент определения этой самой функции.


## Генераторы и обещания
[↑ up](#оглавление) 

Конспект

## ООП с помощью прототипов
[↑ up](#оглавление) 

Конспект