# Роберт Мартин. «Чистый код. Создание, анализ, рефакторинг»

## Предисловие

Мелочи важны. 80% работы программиста — поддержка существующего кода. Применение японского принципа 5S к программированию:
* организация (правила, именование)
* аккуратность (порядок в коде, все на своих местах, легко найти)
* чистка (без мусорных комментариев)
* стандартизация (стиль кодирования, соглашения в команде и сообществе)
* дисциплина (следование правилам, размышления, готовность к изменениям). 
Чистота кода редко важна начальству, надо сделать здесь и сейчас. Но говно всегда возвращается и техдолг растет. Качество = небезразличие. Чистый код божественен (лол). Книга — практическое описание принципов программирования **_Lean_**.

## Введение

Метрика хорошего кода — [количество «чертей» в минуту](http://www.osnews.com/story/19266/WTFs_m)
Профессионализм = знания + опыт. Писать чистый код — тяжело. 3 части книги: теория, практика, эвристические правила.

## Глава 1. Чистый код

Код будет всегда (может быть в другом виде, но будет). Хороший код важен. Плохой код мешает работе, но все равно его пишут — потому что пускай работает хоть как-то, чем совсем никак. Работы по рефакторингу откладываются «на потом» (значит, никогда). По мере накопления хаоса в коде производительность стремиться к нулю. Потом случается глобальная переработка (перехуячить все), куда бросают лучшие силы. Возникает гонка между группой поддержки существующего продукта и группой разработки нового (привет, БМП). На чистку кода надо выделять время, даже вопреки требованиям руководства/бизнеса (аналогия: пациент недоволен тем, как врач долго моет руки). Не устранять опасность грязного кода — непрофессионализм. Единственная возможность соблюдать график и не терять производительность — улучшать код. Отличать плохой код от хорошего != уметь писать хорошо. Чувство кода — умение видеть проблемные места и предлагать пути улучшения. Может быть врожденным или приобретенным. 
Чистый код в определениях топ-программистов:
* Бьерн Страуструп: элегантность, прямолинейность, эффективность. Чистый код хорошо решает одну задачу. 
* Грэди Буч (книга **_Object oriented analysis and design with applications_**): простота, четкие абстракции, удобочитаемость, идеи программиста легко и логично считываются
* Дэйв Томас: понятность, поддерживаемость, тесты, минимум зависимостей и простой краткий API, компактность и грамотность
* Майкл Физерс (книга **_Working effectively with legacy code_**): чистый код выглядит тщательно написанным, нет очевидных способов улучшения, небезразличность
* Рон Джеффрис: тесты, без нарушения DRY, выразительность, минимум сущностей
* Уорд Каннингем (вдохновитель **_Design Patterns_**): делает примерно то, что ожидает читатель кода. Не запутан, логичен, чтение не доставляет трудностей, прост, красив.
Правило бойскаута: оставь место стоянки чище, чем оно было до твоего прихода. Не сразу глобально, а постепенно, постоянно.

## Глава 2. Содержательные имена

Выбор хорошего имени требует усилий и времени, но окупается впоследствии. 
Несколько правил хорошего именования сущностей.

### Имена должны передавать намерения программиста

Не бояться переименовывать переменные, если найден более удачный вариант. Имя несет информацию о том почему переменная существует, что делает, как используется. Если требуется комментарий в коде – имя выбрано неудачно. 

### Избегайте дезинфрмации

Нельзя использовать имена, вызывающие ложные ассоциации. Не использовать в именовании устоявшиеся термины не к месту (например, `accountList`, если речь действительно не идет о списке – конкретной структуре данных). Остерегаться малозаметных различий в именах – это тоже дезинформация + мешает автокомплиту IDE. Остерегаться похожих символов (`1` - `l`, `0` - `O`). 

### Используйте осмысленные различия

Классический пример ошибки: `product1` и `product2`. Чуть сложнее: `Product`, `ProductInfo`, `ProductData` – добавление слов не дает никакой полезной информаци.
**_Сложное правило. Плохие примеры ясны, а как делать хорошо?_**

### Используте удобопроизносимые имена

Код читают. О коде разговаривают. Имена должны нормально произноситься вслух. Избегать дурацких сокращений, непонятных аббревиатур и кодов.
**_В другой книжке есть яркий пример, который живет и процветает – аббревиатура SQL. Принятое на Западе произношение: «сиквел»; у нас же я слышал только «эс-кю-эль»._**

### Выбирайте имена, удобные для поиска

Длинные, запоминающиеся имена ищутся редактором легко. Короткие однобуквенные допустимы лишь для локальных переменных, например для итератора цикла.

### Избегайте схем кодирования имен

Бывает, что в именах переменных кодируют мета-информацию о типе, области видимости и т.д. Не надо так, придется каждому новому разработчику объяснять схему.
**_В тайпскрипте принято интерфесы называть так: `IProduct`. Пример уместного кодирования, полагаю._**

### Венгерская запись

В доисторические времена в названии переменной кодировали как раз мета-инфу, например в Fortran первая буква означала тип. Темные времена прошли, не надо так.

### Префиксы членов класса

Та же штука, раньше была практика переменным класса давать префикс `m_`. 

### Интерфейсы и реализации

А вот и пример с `IProduct`. В нормальных ОО-языках давать префикс интерфейсам считается зашкваром. Менее зашкварно дать префикс-постфикс реализации.
**_Это уже наверное про конкретные случаи, особенности языков и парадигм. Для Typescript всё-таки не зашквар, думаю._**

### Избегайте мысленных преобразований
**_Вот здесь я не понял нихера, даже конспектировать не буду. Кажется, это правило – частный случай правила осмысленного именования и запрета на кодирование._**

### Имена классов

Имена классов – существительные и их комбинации, не глагол. Избегать общих слов типа `Info`, `Data`, `Manager`, `Processor`.

### Имена методов

Глаголы, глагольные словосочетания. По стандарту **_javabean_**: для чтения `get`, для записи `set`, для предикотов (логических утверждений) – `is`.

### Избегайте остроумия

Локальные мемы вжопу. Сюда же – сленг и просторечия. 
**_Где-то около этого пункта: я бы рекомендовал следить за элементарной орфографией и не лениться заглядывать в переводчик. А то знаю я некоторых транслэйтэров, блеать_**

### Выберите одно слово для каждой концепции

Автокомплит поможет подставить имя метода, но не расскажет, чем `fetch` отличается от `get`, а `controller` от `manager`. Терминология должна быть строгой.

### Избегайте каламбуров

Не использовать одно и то же слово в двух разных смыслах.

### Используйте имена из пространства решения

Не стесняться использовать термины CS, названия паттернов, алгоритмов, математические термины. Не забывая при этом про избегание дезинформации.

### Используйте имена из пространства задачи

Термины предметной области приложения – тоже ок.

### Добавьте содержательный контекст

При взгляде на переменную должно быть понятно, в каком смысловом контексте она используется. Например, мы коды статусов оъединяли и экспортировали единым объектом `HTTP`. Так же норм добавлять контекстные префиксы: `customerName`, `customerPhone`.

### Не добавлять избыточный контекст

Будет мешать автокомплиту + в принципе засоряет код, лишние префиксы все равно взглядом будут игнорироваться.

### Напоследок

Для выбора хороших имен нужен описательный навык и единый культурный фон в команде. Этому можно научиться и выработать. Не бояться переименовывать неудачные места. Хорошие имена помогут именно **читать** код + чисто технически добавит удобства в разработке (опять же про автокомплит, хотя бы).