# Роберт Мартин. «Чистый код. Создание, анализ, рефакторинг»

## Предисловие

Мелочи важны. 80% работы программиста — поддержка существующего кода. Применение японского принципа 5S к программированию:
* организация (правила, именование)
* аккуратность (порядок в коде, все на своих местах, легко найти)
* чистка (без мусорных комментариев)
* стандартизация (стиль кодирования, соглашения в команде и сообществе)
* дисциплина (следование правилам, размышления, готовность к изменениям). 
Чистота кода редко важна начальству, надо сделать здесь и сейчас. Но говно всегда возвращается и техдолг растет. Качество = небезразличие. Чистый код божественен (лол). Книга — практическое описание принципов программирования **_Lean_**.

## Введение

Метрика хорошего кода — [количество «чертей» в минуту](http://www.osnews.com/story/19266/WTFs_m)
Профессионализм = знания + опыт. Писать чистый код — тяжело. 3 части книги: теория, практика, эвристические правила.

## Глава 1. Чистый код

Код будет всегда (может быть в другом виде, но будет). Хороший код важен. Плохой код мешает работе, но все равно его пишут — потому что пускай работает хоть как-то, чем совсем никак. Работы по рефакторингу откладываются «на потом» (значит, никогда). По мере накопления хаоса в коде производительность стремиться к нулю. Потом случается глобальная переработка (перехуячить все), куда бросают лучшие силы. Возникает гонка между группой поддержки существующего продукта и группой разработки нового (привет, БМП). На чистку кода надо выделять время, даже вопреки требованиям руководства/бизнеса (аналогия: пациент недоволен тем, как врач долго моет руки). Не устранять опасность грязного кода — непрофессионализм. Единственная возможность соблюдать график и не терять производительность — улучшать код. Отличать плохой код от хорошего != уметь писать хорошо. Чувство кода — умение видеть проблемные места и предлагать пути улучшения. Может быть врожденным или приобретенным. 
Чистый код в определениях топ-программистов:
* Бьерн Страуструп: элегантность, прямолинейность, эффективность. Чистый код хорошо решает одну задачу. 
* Грэди Буч (книга **_Object oriented analysis and design with applications_**): простота, четкие абстракции, удобочитаемость, идеи программиста легко и логично считываются
* Дэйв Томас: понятность, поддерживаемость, тесты, минимум зависимостей и простой краткий API, компактность и грамотность
* Майкл Физерс (книга **_Working effectively with legacy code_**): чистый код выглядит тщательно написанным, нет очевидных способов улучшения, небезразличность
* Рон Джеффрис: тесты, без нарушения DRY, выразительность, минимум сущностей
* Уорд Каннингем (вдохновитель **_Design Patterns_**): делает примерно то, что ожидает читатель кода. Не запутан, логичен, чтение не доставляет трудностей, прост, красив.
Правило бойскаута: оставь место стоянки чище, чем оно было до твоего прихода. Не сразу глобально, а постепенно, постоянно.

## Глава 2. Содержательные имена

Выбор хорошего имени требует усилий и времени, но окупается впоследствии. 
Несколько правил хорошего именования сущностей.

### Имена должны передавать намерения программиста

Не бояться переименовывать переменные, если найден более удачный вариант. Имя несет информацию о том почему переменная существует, что делает, как используется. Если требуется комментарий в коде – имя выбрано неудачно. 

### Избегайте дезинфрмации

Нельзя использовать имена, вызывающие ложные ассоциации. Не использовать в именовании устоявшиеся термины не к месту (например, `accountList`, если речь действительно не идет о списке – конкретной структуре данных). Остерегаться малозаметных различий в именах – это тоже дезинформация + мешает автокомплиту IDE. Остерегаться похожих символов (`1` - `l`, `0` - `O`). 

### Используйте осмысленные различия

Классический пример ошибки: `product1` и `product2`. Чуть сложнее: `Product`, `ProductInfo`, `ProductData` – добавление слов не дает никакой полезной информаци.

**_Сложное правило. Плохие примеры ясны, а как делать хорошо?_**

### Используте удобопроизносимые имена

Код читают. О коде разговаривают. Имена должны нормально произноситься вслух. Избегать дурацких сокращений, непонятных аббревиатур и кодов.

**_В другой книжке есть яркий пример, который живет и процветает – аббревиатура SQL. Принятое на Западе произношение: «сиквел»; у нас же я слышал только «эс-кю-эль»._**

### Выбирайте имена, удобные для поиска

Длинные, запоминающиеся имена ищутся редактором легко. Короткие однобуквенные допустимы лишь для локальных переменных, например для итератора цикла.

### Избегайте схем кодирования имен

Бывает, что в именах переменных кодируют мета-информацию о типе, области видимости и т.д. Не надо так, придется каждому новому разработчику объяснять схему.

**_В тайпскрипте принято интерфесы называть так: `IProduct`. Пример уместного кодирования, полагаю._**

### Венгерская запись

В доисторические времена в названии переменной кодировали как раз мета-инфу, например в Fortran первая буква означала тип. Темные времена прошли, не надо так.

### Префиксы членов класса

Та же штука, раньше была практика переменным класса давать префикс `m_`. 

### Интерфейсы и реализации

А вот и пример с `IProduct`. В нормальных ОО-языках давать префикс интерфейсам считается зашкваром. Менее зашкварно дать префикс-постфикс реализации.

**_Это уже наверное про конкретные случаи, особенности языков и парадигм. Для Typescript всё-таки не зашквар, думаю._**

### Избегайте мысленных преобразований

**_Вот здесь я не понял нихера, даже конспектировать не буду. Кажется, это правило – частный случай правила осмысленного именования и запрета на кодирование._**

### Имена классов

Имена классов – существительные и их комбинации, не глагол. Избегать общих слов типа `Info`, `Data`, `Manager`, `Processor`.

### Имена методов

Глаголы, глагольные словосочетания. По стандарту **_javabean_**: для чтения `get`, для записи `set`, для предикатов (логических утверждений) – `is`.

### Избегайте остроумия

Локальные мемы вжопу. Сюда же – сленг и просторечия. 

**_Где-то около этого пункта: я бы рекомендовал следить за элементарной орфографией и не лениться заглядывать в переводчик. А то знаю я некоторых транслэйтэров, блеать_**

### Выберите одно слово для каждой концепции

Автокомплит поможет подставить имя метода, но не расскажет, чем `fetch` отличается от `get`, а `controller` от `manager`. Терминология должна быть строгой.

### Избегайте каламбуров

Не использовать одно и то же слово в двух разных смыслах.

### Используйте имена из пространства решения

Не стесняться использовать термины CS, названия паттернов, алгоритмов, математические термины. Не забывая при этом про избегание дезинформации.

### Используйте имена из пространства задачи

Термины предметной области приложения – тоже ок.

### Добавьте содержательный контекст

При взгляде на переменную должно быть понятно, в каком смысловом контексте она используется. Например, мы коды статусов оъединяли и экспортировали единым объектом `HTTP`. Так же норм добавлять контекстные префиксы: `customerName`, `customerPhone`.

### Не добавлять избыточный контекст

Будет мешать автокомплиту + в принципе засоряет код, лишние префиксы все равно взглядом будут игнорироваться.

### Напоследок

Для выбора хороших имен нужен описательный навык и единый культурный фон в команде. Этому можно научиться и выработать. Не бояться переименовывать неудачные места. Хорошие имена помогут именно **читать** код + чисто технически добавит удобства в разработке (опять же про автокомплит, хотя бы).

## Глава 3. Функции

Функции – первый уровень структуризации программы. 

### Компактность

Каждая фунция должна быть предельно очевидной и компактной. Предела совершенству здесь нет.

### Блоки и  отступы

В блок `if`, `else`, `while` следует помещать одну строку – вызов другой функции. Это сделает исходную функцию компактнее и послужит документированием кода. Нужно избегать вложенность: упростит чтение кода и опять же сделает функцию более компактной.

### Правило одной операции

Функция должна выполнять только одну операцию, делать это хорошо и не делать ничего другого. Что считать одной операцией: это действие на одном уровне абстракции. Чтобы определить, что в фунции выполняется несколько операций, надо попробовать извлечь из нее другую функцию, которая не являлась бы переформулировкой реализации. Если в функции возможно осмысленное разделение на секции (например: объявления, инициализация, и т.д.) – значит, фунция выполняет несколько операций.

**_Вторую часть (про определение одной операции) понимаю чуть смутно. Нужно найти пример и вернуться к этому разделу._**

### Один уровень абстрации на функцию

Ещё раз – все команды функции (может быть несколько этапов, это не противоречит правилу одной операции) лежат в одном уровне абстрации. Например: `getHtml` – высокий, `getName` – средний, `appendSymbol` – низкий.

**_Примеры операций на разных уровнях абстракции немного изменены. Найти яркий пример из своей работы и добавить._**

### Чтение кода сверху вниз: правило понижения

Код должен читаться как рассказ – сверху вниз спускаясь по уровням абстрации. Иначе говоря: программа = набор **_ТО-абзацев_**, каждый из которых описывает текущий уровень абстрации и ссылается на следующий.

**_ТО-абзац – дефиниция. Например: `renderPageWithSettings` – функция, генерирующая код страницы в соответствии с переданными параметрами._**

### Команды switch

Написать компактный `switch` или цепочку `if/else` очень сложно, потому что`switch` рулит несколькими командами, как правило. Но можно сокрыть эти команды в низкоуровневом классе и не дублировать в коде. Здесь поможет полиморфизм. Переносим `switch` в абстрактную фабрику, в которой вызовы нужных команд проходят полиморфную передачу через интерфейс.

**_Здесь тоже не до конца понятен пример и как делать в js. Надо вернуться и разобраться._**

### Используйте содержательные имена

Имя должны давать понять, что происходит в функции. Не бояться использовать длинные имена, не бояться тратить на это время. Попробовать несколько вариантов. Иногда поиск понятного имени приводит к реструктуризации кода. Ещё нужно быть последовательным в именовании, использовать одинаковую фразеологию. «Функция должна делать примерно то, что вы ожидаете».

### Аргументы функций

Идеал – функция без аргументов(нуль-арная). Допустимы унарные и бинарные функции. Тернарных и пониарных функций нужно избегать. При чтении кода аргументы приходится каждый раз интерпретировать. Часто аргумент и имя функции находятся на разных уровнях абстракции. Большое количество аргументов усложняет тестирование, ведь надо покрыть все кейсы, во всех сочетаниях. Фунции с выходными аргументами – вообще зло. 

**_Выходные – аргументы, чьи значения изменились после выполнения функции. _**

### Стандартные унарные формы

Два распространенных случая использования унарной функции: проверить некторое условия, связанное с аргументом, и обработка аргумента с последующим вызвращением. Нужно выбирать имена, четко отражающих эти разлиция. Ещё один частый вариант – событие. Функция принимает аргумент, и производит некоторые изменения состояния системы. Опять же – имя должно давать понять, что перед нами именно событие. Следует избегать иных форм унарных функций (речь опять же про выходные аргументы).

### Аргументы-флаги

Вызов фунции типа `render(true)` – это ж пиздец. Сбивает с толку, нужно лезть смотреть сигнатуру + в функции явно будет выполнения нескольких операций.

### Бинарные функции

Бинарные функции сложнее в понимании. Совсем лютый ужас – когда в вызове таких функций первый параметр должен игнорироваться. В двух аргументах функции нужен логичный естественный порядок, например: `getCoords(latitude, longitude)`. Если связь условна, то легко перепутать. Бинарные функции – не зло, но следует попробовать преобразовать их в унарные. Например, поиграться с ООП.

**_В конце главы описаны варианты игр с ООП, которые я не очень хорошо понял. Вернуться, написать свои примеры._**

### Тернарные функции

Разобраться с тремя аргументами ещё сложнее.

### Объекты как аргументы

Если есть 2-3-n аргументов – может их упаковать в отдельный класс? Это может показаться жульничеством, но если переменные передаются совместно, и жить друг без друга не могут, значит это отдельная концепция, заслуживающая своего имени.

### Списки аргументов

Если в функцию передается переменное количество аргументов, то есть смысл заключить их в `List`

### Глаголы и ключевые слова

Хорошее имя функции способно рассказать о порядке/обязательности аргумента. Для этого могут служить глаголы и ключевые слова. Например: `writeField(name)`, `assertExpectedEqualsActual(expected, actual)`.

### Избавьтесь от побочных эффектов

Побочные эффекты – зло. Функция обещает делать что-то одно, но скрыто совершает что-нибудь дополнительно. Побочные эффекты часто должны быть исполнены в определенный момент времени. За временными привязками следить сложно, особенно когда они скрыты в сайдэффекте. Ну и опять же – правило одной операции нарушается.

### Выходные аргументы

Выходные аргументы заставляют обращаться к сигнатуре, а это нарушает ритм чтения кода. Следует их избегать.

### Разделение команд и запросов

Частный случай принципа одной операции. Функция может изменять состояние объекта или возвращать информацию о нем, но не одновременно. Получится ад. Например, сделать `set(name)`, и если успех – вернуть `true`. Потом начинается использование типа `if (set('unclebob')  {...}` – жесть.

### Используйте исключения вместо возвращения кодов ошибок

Вовзвращать коды ошибок и обрабытывать их – частный случай разделения команд и запросов. Вместо этого лучше воспользоваться `try/catch`. 

### Изолируйте блоки try/catch

`try/catch` смешивает обработку ошибок с нормальным выполнением функции, поэтому из следует выносить в отдельную функцию. Обработка ошибок должна быть одной операцией, и после `catch/finally` не должно быть ничего другого.

**_Хороший прием. Посмотреть пример в книге, и написать свой – очень должен пригодится._**

### Магнит зависимостей Error.java

Обычно создают класс/перечисление всех кодов ошибок, и потом используют во всех остальных классах. Тут есть нюанс **_(который я не очень уловил, поскольку не знаю Java. Вернуться и проанализировать.)_**

### Не повторяйтесь (DRY)

Дублирование кода увеличивает его объем, делает сложным поддержку/рефакторинг, увеличивет вероятность ошибки. Не надо так.

### Структурное программирование

Спорное правило. Оно говорит о том, что функция должна иметь одну точку входа и одну точку выхода. Следствие: в функции должен быть единственный `return`, в циклах/свичах нельзя использовать `break/continue`, команды `goto` – под запретом. Дядя Боб не против, если ты не будешь следовать этому правилу, при условии что функции будут компактными.

### Как научиться писать такие функции?

Программирование – тоже сочинительство. Сначала излагаешь мысли, потом «причёсываешь». Пытаться сразу писать чисто не надо.

### Завершение

Искусство программирования – это искусство языкового проектирования (где функции – глаголы, а класы – существительные). Средства языка нужно применять для создания более высокоуровневого предметно-ориентированного языка, описывающего вашу систему. Иерархия функций очень поможет. Конечная цель – написать легко читаемый рассказ, «историю системы».

## Глава 4. Комментарии

Уместные комментарии – хорошо. Бессодержательные, безапелляционные, устаревшие комментарии – плохо.
Комментарии нужны из-за невыразительности языка и нашего неумения им пользоваться. Комментарий компенсирует нашу неудачу в выражении мыслей. Идеально, если код понятен без комментария.
Комментарит – зло: ведь обычно сопровождением комментариев никто не занимается, следовательно они устаревают, становятся неверными. Неточный комментарий к коду вреднее, чем его отсутсвие. Истина все равно в коде.

### Комментарии не компенсируют плохого кода

Не нужно писать пояснения к запутанно написаному модулю: лучше отрефакторить и сделать проще. Не тратьте время на комментирование, тратьте на исправление.

### Объясните свои намерения в коде

Следить за наименованием функций и переменных – они могут избавить от комментирования.

### Хорошие комментарии

#### Юридические комментарии

Например, заявление об авторских правах. Чаще всего, достаточно короткого комментария со ссылкой на полный текст.

#### Информативные комментарии

Некоторая полезная информация о реализации. Например: подсказать, что возвращает функция, или какие параметры принимает. 

#### Представление намерений 

Раскрывает намерения вашего архитектурного или логического решения. Отвечает на вопрос: «А почему тут так?»

#### Прояснения

Перевод загодочных аргументов или возвращаемых значений на человеческий язык. Трудно поддерживать, постарайтесь найти иное решение этой проблемы.

#### Предупреждения о последствиях

Информирование о нежелательных последствиях выполнения того или иного кода.

#### Комментарии TODO

`// TODO` как план на будущее: сделать необходимо, но не получится прямо сейчас.

#### Усиление

То же самое, что и представление намерений, но там где это незаметно и можно проебать.

#### Комментарии Javadoc в общедоступных API

Пишешь апишку – напиши комментарии к ней.

### Плохия комментарии

О, их будет гораздо больше.

#### Бормотание

Хочешь написать комментарий – пиши понятно. Не допускайте таких комментариев, для понимания которых придется залезть в другие фукнции/модули.

#### Избыточные комментарии 

Комментарии капитана Очевидность. Дублирует название функции.

#### Недостоверные комментарии

Ложь в комментарии – устаревшая информация или просто невнимательность.

#### Обязательные комментарии

Бессмысленная херня, когда зачем-то комментируют каждую функцию.

#### Журнальные комментарии

Когда-то программисты дописывали в начале модуля журнал всех изменений. Сейчас есть гит и не надо так.

#### Шум

Это комменты КО и прочий мусор. Это эе тоже придется поддерживать, иначе будет опасненько. 

#### Не используйте комментарии там, где можно использовать фукцию или переменную

**_В этом заголовке – содержание всей главы_** 

#### Позиционные маркеры

`// Actions ////////////`
Форматирование кода с помощью комментариев-заголовков – только там, где это приносит ощутимую пользу.

#### Комментарии за закрывающей фигурной скобкой

Типа, чтобы не потеряться в многострочной функции/цикле/т.п.:
`while { .... } // while`
Лучше переписать функцию покороче.

#### Ссылки на авторов

Опять же: наследие эпохи до VCS.

#### Закомментированный код

Если код не нужен – удоли.

#### Комментарии HTML

Когда в тексте комментария встречается разметка – это трудно читать.

#### Нелокальная информация

Комментарий должен описывать тот кусок кода, рядом с которым написан.

#### Слишком много информации

Иногда в комменты запихивают чуть ли не статьи с Википедии. Не надо так.

#### Неочевидные комментарии

Если комментарий нуждается в объяснении – он плохой.

#### Заголовки функций

Нужно нормально выбирать имена.

#### Заголовки Javadoc во внутреннем коде

Не приносит пользы, если это не общедоступный код.

## Глава 5. Форматирование

Уважение к деталям – хорошо. Зафиксируйте в своей группе правила оформления кода и седуйте им.

### Цели форматирования

Стиль кодирования и удобочитаемость имеют большое влияние на сопровождаемость и расширяемость кода

### Вертикальное форматирование

Приводится небольшое исследование размера исходных файлов программ на Java (Junit – меньше, Tamcat – больше)

#### Газетная метафора

Структура файла должна напоминать газетную статью: заглавие, краткое содержание в первом абзаце, а дальше уже факты, подробности. Чем дальше к концу – тем подробнее и ниже уровень абстрации.

#### Вертикальное разделение концепций

Строка = выражение, условие. Группа строк = законченная мысль. Мысли следует разделять пустыми строками.

#### Вертикальное сжатие

Вертикальное разрежение разделяет концепции, сжатие – наоборот, подчеркивает тесную связь.

#### Вертикальные расстояния

По коду трудно навигироваться, приходится постоянно прыгать между кусками кода и файлами. Связанные друг с другом концепции должны распологаться по соседству. 
Переменные объявлять как можно ближе к месту использования. 
Переменные экземпляров – в начале класса, так как используются многими методами класса (в С++ поступают наоборот, размещая переменные внизу. Так или иначе, надо их держать вместе и не прятать где-то в середине). 
Вызывающая функция должна находится над вызываемой.
Концептуально родственные участки должны распологаться поблизости (например, группа функций, выполняющих аналогичные операции).

#### Вертикальное упорядочение

Еще раз: от высоких абстракций к низким, от вызывающих функций к вызываемым.

### Горизонтальное форматирование

Исследование длин строк в файлах. Оптимально – до 120 символов.

#### Горизонтальное разделение и сжатие

Группировки связанных элементов и разделения разнородных.
Знаки присваивания окружаются пробелами, аргументы не отделяются от имени функции, сами аргументы разделяются пробелами.
В формулах: множители не разделяются пробелами (высокий приоритет операции), слагаемые – разделяются (низкий приоритет). Такой фичи чаще всего нет в инструментах автоматического форматирования, а жаль.

#### Горизонтальное выравнивание

Нет пользы выравнивать группу объвлений переменных а-ля таблица. Более того, выявляется важный дефект: если хочется выровнять длинный список – это признак того, что его нужно сократить.

#### Отступы

Отступы создают иерархию: классы > методы > блоки внутри методов. Не стот нарушать систему отступов для коротких блоков, вытягивая их в одну строку.

#### Вырожденные области видимости

Иногда тело цикла не содержит команд – является вырожденным. Их стоит избегать, но если не получается – правильно отбивать отступами и скобками.

### Правила форматирования в группах

Код продукта должен быть оформлен в одном стиле. Потратьте 10 минут и зафиксируйте правила оформления в вашей команде. 


