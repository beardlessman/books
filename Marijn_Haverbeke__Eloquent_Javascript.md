# Marijn Haverbeke. «Выразительный Javascript»

## 2-е издание. Перевод Вячеслава Голованова

## Оглавление

- [Введение](#введение)
- [О программировании](#о-программировании)
- [1. Величины, типы и операторы](#Величины-типы-и-операторы)

- [3. Функции](#Функции)

## Введение

[↑ up](#оглавление)

Для коммуникации с компьютером можно воспользоваться двумя подходами: построить интерфейс, имитирующий знакомые нам ощущения из физического мира, или использовать язык (тоже интерфейс). Эта книга рассказывает о языке JavaScript в достаточной мере, чтобы заставить комьютер делать то, что вам нужно.

## О программировании

[↑ up](#оглавление)

Базовые принципы программирования просты, но программы вырастают в сложную систему, порождающую собственные правила и абстракции. Учиться программированию сложно, однако однажды изученное остается с вами навсегда, облегчая дальнейшие шаги.
Сложность программ и в том, что по сути это данные в памяти — инструкции для управления этой же памятью. Компьютер умеет выполнять довольно простые операции, но очень быстро. Программа комбинирует эти операции так, чтобы выполнять сложные действия. Программа — это мысленная конструкция.
Основная проблема программирования — контроль сложности. Нужно быть осторожным чтобы не запутаться. Для контроля сложности выделены конкретные техники (best practices), однако программирование ими не ограничено. Ландшафт вожможных техник изучен крайне мало. Постоянно попадаются новые задачи, важно не бояться их. Ибо это и есть кайф и развитие.

### Язык имеет значение

Первые компьютеры — массивы переключателей/перфокарты. Программы — набор 0 и 1. Сложно, неудобно.
Современные программы ­— набор человекочитаемых инструкций. Короче, понятнее, легче: за счет абстракции.
Хороший язык помогает строить свои абстракции, еще выше уровнем.

## Величины, типы и операторы

[↑ up](#оглавление)

Есть только даныые: их можно читать, изменять, создавать новые. Все данные хранятся как последовательность бит.

### Величины

Величина — кусок данных, единица информации определенного типа (роли). Типов шесть: числа, строки, булины, объекты, функции и неопределенные величины.

### Числа

JS использует 64 бита для хранения численных величин. Не все числа меньше 2^64 помещаются в число JS: один из битов хранит знак числа (для отрицательных чисел), и еще часть битов — позицию десятичной точки (для дробей).
Очень большие или маленькие чила записываются через экспоненту: `2.99e8` (= 2.998 \* 10^8).
Вычисления с целыми числами будут гарантированно точными. Вычисления с дробями — нет.

### Арифметика

Для арифметических действий используются операторы (`+`, `-`, `*`, `/`, `%`), для указания приоритета операций — скобки.

### Специальные числа

`Infinity`, `-Infinity`: положительная и отрицательная бесконечность.
`NaN` (not a number) — величина числового типа, результать арифметической операции, не приводящий к точному осмысленному результату. Например, 0/0.

### Строки

Хранение текстовых данных. Использует парные кавычки. Для спец символов используется экраниерование обратным слешем (`\"`). Экранировать можно любой символ.
Строки нельзя умножать, делить, вычитать, складывать. Но можно конкатериновать через оператор `+`.

### Унарные операторы

Оператор, работыющий с одной величиной (в отличии от предыдущих бинарных). Например, `typeof`.

### Булевские величины

`true` и `false`. Величина, показывающая одну из двух возможностей(да/нет, вкл/выкл).

### Сравнения

Результат — булевское значение. Например, бинарные операторы «меньше» `<` и «больше» `>`. Другие операторы сравнения: `<=`, `>=`, `==`, `!=`.
Сравнение строк основано на стандарте Unicode (каждому символу соответствует числовой код).
В JS только одна величина не равна сама себе — `NaN`.

### Операции с булевскими значениями

Логические операторы: и, или, нет.
`&&` — логическое «и» — результат true только если обе величины true
`||` — логическое «или» — результат true, если хотя бы одна true
`!` — логическое «нет» — обращает величину на обратную.
Еще один — тернарный условный оператор `<condition> ? <result if true> : <result if false>`.

### Приоритет

Возрастание приоритета в ряду: или < и < сравнение < все остальные операторы

### Неопределенные значения

`null` и `undefined`. Обозначают отсутствие осмысленного значения, существенной разницы нет.
Зачастую, если нет результата операции, то возвращается `undefined`.

### Автоматическое преобразование типов

Любая операция в JS возможна. Если оператор применяется «не к тому» типу, произойдет приведение типов (coercion).
При сравнении двух величин, если мы хотим проверить абсолютную идентичность, следует использовать строгое сравнение: `===` и `!==`. При нем приведение типов не происходит.

### Короткое вычисление логических операторов

Как работают `&&` и `||` с величинами разных типов.
`||` вернет величину слева, если она преобразуется в true, иначе — величину справа. Можно использовать как откат к дефолтным значениям: если выражение слева false, вернется дефолтное значение (справа).
`&&` вернет величину слева, если она преобразуется в false, иначе — величину справа.
Выражение справаа вычисляется только при необходимости. Например, true || Х : чему равен Х — неважно. Это и есть короткое вычисление. С тернарным оператором условия та же штука: условие вычисляется всегда, а дальше — зависит от.

## Функции

Определение функции:

```
var square = function(x) {
  return x * x;
};
```

или

```
function square(x) {
  return x * x;
}
```

Разница в том, что во втором случае происходит поднятие переменной `square` (она доступная к использованию выше, чем определяется, т.е. доступна в любом месте кода в пределах данной области видимости).

Ключевое слово `function`, параметр `x` (может быть несколько, или ни одного), тело в фигурных скобках.
Инструкция `return` заканчивает выполнение функции и возвращат некоторое значение. Если функция не имеет `return` (выполняет только побочные действия) считается, что она вернула `undefined`.

Переменные внутри функции (включая параметры) -- локальные (находятся в локальной области видимости). Они создаются каждый раз при вызове функции и с каждым вызовом эти инкарнации переменных друг с другом не связаны. В противовес локальным есть глобальные переменные. Такая переменная тоже доступна в функции со значением, заданным в глобальном коде (глобальной области видимости), если не перетерты локальной переменной с таким же именем.
Функции внутри себя могут вызывать другие функции, и тогда области видимости выстраиваются в луковицу -- слои.
Со стандартом ES6 области видимости доступны еще и на уробне блоков кода `{}`.

Не стоит объявлять функции в условном блоке или в цикле. Платформы для запуска JS могут по разному их обработать. Текущий стандарт языка запрещает это.

```
function example() {
  function a() {} // Нормуль
  if (something) {
    function b() {} // Ай-яй-яй!
  }
}
```

Стек вызовов. Начинаем с глобального уровня и двигаемся вглубь. После выполнения функции она отдает управление на уровень выше (должна вернуться на то место, откуда её вызвали). Интерпретатор запоминает контексты вызова, работает с ними как со стеком.

JS лоялен к количеству аргументов. Если их больше, чем нужно -- лишние проигнорируются. Если меньше -- недостающим будет назначено `undefined`.

Замыкание -- возможность работать со ссылкой на экземпляр локальной переменной. Переменные создаются заново для каждого вызова функции. Доступ к переменным сохраняется даже после того, как функция закончила работу:

```
function wrapValue(n) {
  var localVariable = n;
  return function() { return localVariable; };
}

var wrap1 = wrapValue(1);
var wrap2 = wrapValue(2);
console.log(wrap1());
// → 1
console.log(wrap2());
// → 2
```

Рекурсия -- вызов функции самой себя (надо следить за стеком вызовов). Как правило, рекурсия медленнее, чем цикл (но выглядит лаконично и эффектно). Не стоит оптимизировать раньше, чем обнаружена неэффективность решения: сначала найти узкое место, потом его править.

Где и как используются функции? 
1. устранение дублирования кода
2. создание новой функциональности, которая будет помещена в функцию (придумали название -- реализовали)

Типы функций: те, которые вызываются для получения результата (`return`); и те, которые нужны для побочных действий (ввод-вывод и т.д.) + их комбинация.
Чистая функция -- не имеет побочных действий и не зависит от побочных действий остального кода (не работает с глобальными переменными, вводом-выводом, ..., т.е. одинаково работает в любом контексте). При вызове с одними и теми же аргументами всегда возвращает одинаковый результат.


